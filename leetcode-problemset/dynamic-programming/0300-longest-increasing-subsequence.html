<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LeetCode 第 300 题：“最长上升子序列”题解 | LeetCode 题解</title>
    <meta name="description" content="期待有一天，我能写成《算法图解》送给你。">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    
    <link rel="preload" href="/leetcode-solution-blog/assets/css/0.styles.abe86843.css" as="style"><link rel="preload" href="/leetcode-solution-blog/assets/js/app.465160d1.js" as="script"><link rel="preload" href="/leetcode-solution-blog/assets/js/2.3821944f.js" as="script"><link rel="preload" href="/leetcode-solution-blog/assets/js/61.8982a5c8.js" as="script"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/10.fefa1741.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/100.b32db755.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/101.0bb909d5.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/102.1e213ac7.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/103.9e203f19.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/104.832f9529.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/105.b8cac07d.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/106.78008a9f.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/11.a0fc7712.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/12.8ba7824d.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/13.57523aa1.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/14.722f3bcf.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/15.a350f55f.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/16.80fbec41.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/17.1518d6a3.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/18.0d4a9205.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/19.01e2cb83.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/20.4f849ed2.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/21.0ec3b2dc.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/22.a4e612f0.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/23.786a69e7.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/24.b197066a.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/25.306308b7.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/26.af023872.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/27.efb7f3aa.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/28.0c36d326.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/29.074ee07e.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/3.936fd1fe.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/30.c9a4b013.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/31.3d4dee14.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/32.1449c749.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/33.ebf05b6a.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/34.ffb883e4.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/35.39b91844.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/36.b4ed9a77.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/37.cd80b254.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/38.4f13addf.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/39.27e60c74.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/4.050fc766.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/40.c0b7bb25.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/41.ec92a08f.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/42.fb01b161.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/43.a3dc535b.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/44.ff7cf920.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/45.b28dad77.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/46.861e9845.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/47.bb63c39c.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/48.a9b9b42c.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/49.7ea3e939.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/5.36218812.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/50.d30baa79.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/51.d2ee7be5.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/52.fc282c7b.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/53.0da0b555.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/54.e82f8261.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/55.17bfd847.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/56.c65c6d6e.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/57.818ddb8e.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/58.44d56853.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/59.df6802c3.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/6.817a7dcb.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/60.35ed02fc.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/62.8015ae9c.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/63.c484de09.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/64.d8ba4730.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/65.b4ce6ffc.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/66.9b940e7b.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/67.0a4c6e93.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/68.e0db5d34.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/69.a3bddab7.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/7.3a2cec05.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/70.1f079c69.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/71.51010eda.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/72.6980c338.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/73.84a10f9c.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/74.f241d52d.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/75.64e3638f.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/76.3ff612b8.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/77.13d9831f.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/78.6d6e7097.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/79.3b335b07.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/8.51802152.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/80.18eb4985.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/81.f2e5a5b8.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/82.2de168e8.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/83.416b5578.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/84.102cf249.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/85.3c16c80d.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/86.a11f0e41.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/87.e6855ff7.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/88.7fabf60a.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/89.42666fe4.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/9.aae0ba99.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/90.0c0a6e24.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/91.01b7a895.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/92.7b80d327.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/93.9c3c5bf4.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/94.632bac9e.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/95.985ff765.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/96.12d901f2.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/97.7c0f5e34.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/98.bf1dc6ba.js"><link rel="prefetch" href="/leetcode-solution-blog/assets/js/99.9f5f2baa.js">
    <link rel="stylesheet" href="/leetcode-solution-blog/assets/css/0.styles.abe86843.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/leetcode-solution-blog/" class="home-link router-link-active"><!----> <span class="site-name">LeetCode 题解</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/leetcode-solution-blog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">LeetCode 题解</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/" class="nav-link router-link-active">动态规划</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/binary-search/" class="nav-link">二分查找</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/backtracking/" class="nav-link">回溯算法</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/breadth-first-search/" class="nav-link">广度优先搜索</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/depth-first-search/" class="nav-link">深度优先搜索</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/stack/" class="nav-link">栈</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/heap/" class="nav-link">堆</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/bit-manipulation/" class="nav-link">位运算</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/bucket-sort/" class="nav-link">桶排序</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/greedy/" class="nav-link">贪心算法</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/topological-sort/" class="nav-link">拓扑排序</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/linked-list/" class="nav-link">单链表</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/tree/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/divide-and-conquer/" class="nav-link">分治算法</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/hash-table/" class="nav-link">哈希表</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/ordered-map/" class="nav-link">二分搜索树</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/sliding-window/" class="nav-link">滑动窗口</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/two-pointers/" class="nav-link">双指针</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/trie/" class="nav-link">字典树</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/binary-indexed-tree/" class="nav-link">树状数组</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/union-find/" class="nav-link">并查集</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">LeetCode 周赛</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-weekly-contest/166/" class="nav-link">第 166 场周赛</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-weekly-contest/165/" class="nav-link">第 165 场周赛</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-biweekly-contest/14/" class="nav-link">第 14 场双周赛</a></li></ul></div></div><div class="nav-item"><a href="/leetcode-solution-blog/choice-goods/" class="nav-link">精选文章</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">社交网站</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>工作</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://www.liwei.party/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://github.com/liweiwei1419" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://leetcode-cn.com/u/liweiwei1419" target="_blank" rel="noopener noreferrer" class="nav-link external">
  LeetCode 主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://www.jianshu.com/u/df77cffc27f2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://blog.csdn.net/lw_power" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://juejin.im/user/5d3c091b51882565f2663bea" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li><li class="dropdown-item"><h4>生活</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://www.weibo.com/u/2194939432" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="http://5sing.kugou.com/7322929/default.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  听我唱歌
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/leetcode-solution-blog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">LeetCode 题解</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/" class="nav-link router-link-active">动态规划</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/binary-search/" class="nav-link">二分查找</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/backtracking/" class="nav-link">回溯算法</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/breadth-first-search/" class="nav-link">广度优先搜索</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/depth-first-search/" class="nav-link">深度优先搜索</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/stack/" class="nav-link">栈</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/heap/" class="nav-link">堆</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/bit-manipulation/" class="nav-link">位运算</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/bucket-sort/" class="nav-link">桶排序</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/greedy/" class="nav-link">贪心算法</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/topological-sort/" class="nav-link">拓扑排序</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/linked-list/" class="nav-link">单链表</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/tree/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/divide-and-conquer/" class="nav-link">分治算法</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/hash-table/" class="nav-link">哈希表</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/ordered-map/" class="nav-link">二分搜索树</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/sliding-window/" class="nav-link">滑动窗口</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/two-pointers/" class="nav-link">双指针</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/trie/" class="nav-link">字典树</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/binary-indexed-tree/" class="nav-link">树状数组</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-problemset/union-find/" class="nav-link">并查集</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">LeetCode 周赛</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-weekly-contest/166/" class="nav-link">第 166 场周赛</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-weekly-contest/165/" class="nav-link">第 165 场周赛</a></li><li class="dropdown-item"><!----> <a href="/leetcode-solution-blog/leetcode-biweekly-contest/14/" class="nav-link">第 14 场双周赛</a></li></ul></div></div><div class="nav-item"><a href="/leetcode-solution-blog/choice-goods/" class="nav-link">精选文章</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">社交网站</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>工作</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://www.liwei.party/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://github.com/liweiwei1419" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://leetcode-cn.com/u/liweiwei1419" target="_blank" rel="noopener noreferrer" class="nav-link external">
  LeetCode 主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://www.jianshu.com/u/df77cffc27f2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://blog.csdn.net/lw_power" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="https://juejin.im/user/5d3c091b51882565f2663bea" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li><li class="dropdown-item"><h4>生活</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://www.weibo.com/u/2194939432" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-subitem"><a href="http://5sing.kugou.com/7322929/default.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  听我唱歌
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>动态规划专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0221-maximal-square.html" class="sidebar-link">LeetCode 第 221 题：最大正方形（中等）</a></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0003-longest-substring-without-repeating-characters.html" class="sidebar-link">LeetCode 第 3 题：“无重复字符的最长子串”题解</a></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0005-longest-palindromic-substring.html" class="sidebar-link">LeetCode 第 5 题：“最长回文子串”题解</a></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0053-maximum-subarray.html" class="sidebar-link">LeetCode 第 53 题：“最大子序和”题解</a></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0139-word-break.html" class="sidebar-link">LeetCode 第 139 题：“单词拆分”题解</a></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0300-longest-increasing-subsequence.html" class="active sidebar-link">LeetCode 第 300 题：“最长上升子序列”题解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0300-longest-increasing-subsequence.html#动态规划-贪心算法（二分法）（python-代码、java-代码）" class="sidebar-link">动态规划 + 贪心算法（二分法）（Python 代码、Java 代码）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0300-longest-increasing-subsequence.html#审题" class="sidebar-link">审题</a></li><li class="sidebar-sub-header"><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0300-longest-increasing-subsequence.html#方法一：动态规划" class="sidebar-link">方法一：动态规划</a></li><li class="sidebar-sub-header"><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0300-longest-increasing-subsequence.html#方法二：贪心算法-二分查找" class="sidebar-link">方法二：贪心算法 + 二分查找</a></li></ul></li></ul></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0377-combination-sum-iv.html" class="sidebar-link">LeetCode 第 377 题：“组合总和 Ⅳ”题解</a></li><li><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0416-partition-equal-subset-sum.html" class="sidebar-link">LeetCode 第 416 题：“分割等和子集”题解</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="leetcode-第-300-题：“最长上升子序列”题解"><a href="#leetcode-第-300-题：“最长上升子序列”题解" aria-hidden="true" class="header-anchor">#</a> LeetCode 第 300 题：“最长上升子序列”题解</h1> <p>题解地址：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener noreferrer">动态规划 + 贪心算法（二分法）（Python 代码、Java 代码）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p> <p>传送门：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener noreferrer">300. 最长上升子序列<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p> <p>示例:</p> <p>输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p></blockquote> <h2 id="动态规划-贪心算法（二分法）（python-代码、java-代码）"><a href="#动态规划-贪心算法（二分法）（python-代码、java-代码）" aria-hidden="true" class="header-anchor">#</a> 动态规划 + 贪心算法（二分法）（Python 代码、Java 代码）</h2> <p>最长上升子序列，英文名 Longest Increasing Subsequence，是著名的 LIS 问题。</p> <p>本文介绍了两种方法解决这个问题，第一种是常规解法：动态规划，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，第二种方法有一定技巧性，可以认为是贪心算法 + 二分查找，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 表示数组的长度。</p> <h3 id="审题"><a href="#审题" aria-hidden="true" class="header-anchor">#</a> 审题</h3> <p>首先对题目中“上升”和“子序列”这两个关键字做一些解释，以帮助您更好地理解 LIS 问题。</p> <p>1、子序列（Subsequence）：“子序列”<strong>并不要求是连续子序列</strong>，只要保证元素前后顺序一致即可，例如：序列 <code>[4, 6, 5]</code> 是 <code>[1, 2, 4, 3, 7, 6, 5]</code> 的一个子序列；</p> <p>2、上升：这里“上升”要求<strong>严格</strong>“上升”。</p> <p>例如一个序列 <code>[2, 3, 3, 6, 7]</code> ，由于 <code>3</code> 重复了，所以不是<strong>严格</strong>“上升”的，因此它不是题目要求的“上升”序列。</p> <p>一个序列可能有多个最长上升子序列，题目中只要我们求这个最长的长度。如果使用回溯算法，选择所有的子序列进行判断，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><msup><mn>2</mn><mi>N</mi></msup><mo>)</mo><mo>∗</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O((2^N) * N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p> <p>LIS 问题是一个最优化问题，可以考虑使用动态规划完成。</p> <h3 id="方法一：动态规划"><a href="#方法一：动态规划" aria-hidden="true" class="header-anchor">#</a> 方法一：动态规划</h3> <p>“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。</p> <p>有的资料又将“动态规划”分为 3 步：</p> <ul><li>base case：思考问题规模最小的时候，是什么情况；</li> <li>update function：自下而上思考这个问题，即上面的“状态转移方程”；</li> <li>gola：重点强调了输出是什么，很多时候输出并不一定是最后一个状态。</li></ul> <p>我觉得这种分法更细致一点，“状态”以及“状态转移方程”也没有问题，但是我觉得还要加上一个，思考一下“输出”是什么，即将第 2 种的第 3 步加上去，在下面的分析中，我还会强调这一点。</p> <p><strong>1、定义状态</strong></p> <p>首先我们考虑能否将题目的问法定义成状态，即 <code>dp[i]</code> 表示长度为 <code>i</code> 的最长上升子序列的长度，但仔细思考之后，我们发现：<strong>由于“子序列”不要求连续</strong>，长度为 <code>i - 1</code> 的最长上升子序列，与长度为 <code>i</code> 的“最长上升子序列之间的递推关系并不那么容易得到。</p> <p>但我们由<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener noreferrer">「力扣」第 3 题：“无重复字符的最长子串”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>以及<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener noreferrer">「力扣」第 53 题：“最大子序和”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这两个问题的经验，再结合题意，可以知道，“上升”的递推关系是：看子序列最后一个数，如果一个新数，比子序列最后一个数还大，那么就可以放在这个子序列的最后，形成一个更长的子序列。反正一个子序列一定会以一个数字结尾，那我就将状态成以 <code>nums[i]</code> 结尾的“最长上升子序列”的长度，这一点是常见的。</p> <p><code>dp[i]</code>：表示以第 <code>i</code> 个数字为结尾的“最长上升子序列”的长度。即在 <code>[0, ..., i]</code> 的范围内，选择 <strong>以数字 <code>nums[i]</code> 结尾</strong> 可以获得的最长上升子序列的长度。注意：以第 <code>i</code> 个数字为结尾，即 <strong>要求 <code>nums[i]</code> 必须被选取</strong>。</p> <p>初始化的时候，因为每个元素自己可以认为是一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 的子序列，所以可以将 <code>dp</code> 数组的值全部设置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>。</p> <p><strong>定义输出</strong>：<strong>下面要考虑一下输出，由于状态不是题目中的问法，因此不能将最后一个状态作为输出</strong>，这里输出是把 <code>dp[0]</code>、<code>dp[1]</code>、……、<code>dp[n - 1]</code> 全部看一遍，取最大值。</p> <p><strong>2、推导“状态转移方程”</strong></p> <p>遍历到索引是 <code>i</code> 的数的时候，根据上面“状态”的定义，考虑把 <code>i</code> 之前的所有的数都看一遍，只要当前的数 <code>nums[i]</code> 严格大于之前的某个数，那么 <code>nums[i]</code> 就可以接在这个数后面形成一个更长的上升子序列。因此，<code>dp[i]</code> 就是之前<strong>严格</strong>小于 <code>nums[i]</code> 的“状态”最大值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>。</p> <p>因此，状态转移方程是：</p> <div class="language-python extra-class"><pre class="language-python"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">{</span><span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token operator">&lt;</span> i <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre></div><p>看下面的例子或者代码来理解这个状态转移方程。</p> <p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p> <p><img src="https://pic.leetcode-cn.com/9681bb5aa5712f0ca6bb577ca0d21df805f72f6b3b5b95c3d5340801118d5683-300-dp-1.png" alt="300-dp-1.png">,<img src="https://pic.leetcode-cn.com/158c37377e1e3efbb0cba7858187a9d66428ef991c5f05c59e3a7dab6b509436-300-dp-2.png" alt="300-dp-2.png">,<img src="https://pic.leetcode-cn.com/92d5014ce051b31aff242f10c7d9735e6e3b6e35f567e9a2663ce04075390d3d-300-dp-3.png" alt="300-dp-3.png">,<img src="https://pic.leetcode-cn.com/30739cd98770a4ca9e02a78971a23b5d1030d0b5135223cc419045a2dabdaecb-300-dp-4.png" alt="300-dp-4.png">,<img src="https://pic.leetcode-cn.com/a9d0dd0c2e1292d466f86f7fa980bf854bc9a0be0f90720a7d9823ba532becf9-300-dp-5.png" alt="300-dp-5.png">,<img src="https://pic.leetcode-cn.com/fdb3efd26dd0972f65ad7c3a5ac53022b8d43954f31919403d4cd2ef48ac8d67-300-dp-6.png" alt="300-dp-6.png">,<img src="https://pic.leetcode-cn.com/a495f476c50e8dbbc20b76cec1e97454e060b9fbfae4a12e205b87ea75ae0bdc-300-dp-7.png" alt="300-dp-7.png">,<img src="https://pic.leetcode-cn.com/2ca152b9864efd08d1c3d030f2544d794ac6d26deff3bfd451c8fd0d67f88799-300-dp-8.png" alt="300-dp-8.png">,<img src="https://pic.leetcode-cn.com/53e09c8ad0fb0c8d9fa1954222228b834ad5cbdb531e2efc06230b574873a122-300-dp-9.png" alt="300-dp-9.png">,<img src="https://pic.leetcode-cn.com/fe7d46471345771c83c5675fb3deb07efea784d206e964befea4b5413eea3392-300-dp-10.png" alt="300-dp-10.png"></p> <p>再看一个例子，熟悉“状态转移”的过程：</p> <p><img src="https://pic.leetcode-cn.com/aadddcb53c38bd0f53683342b02b2f709891b9d29c75ea1b50d931babd124f19-300-dp-1.png" alt="300-dp-1.png">,<img src="https://pic.leetcode-cn.com/41de288576b67efc89d3bb77ecba22308255f6a68f93e68a29a4075782e132b8-300-dp-2.png" alt="300-dp-2.png">,<img src="https://pic.leetcode-cn.com/703cfb3ab438c60bea10f1ace4e38768feae435e0c1b34588244893164ac7fb8-300-dp-3.png" alt="300-dp-3.png">,<img src="https://pic.leetcode-cn.com/5cc64714962ab402b92bd9687f41d84743eb2c3dc84bfad16ce9fd227891bb9f-300-dp-4.png" alt="300-dp-4.png">,<img src="https://pic.leetcode-cn.com/5ab427441dd436f40d8fbaf3b60176e971b59da800dfcf8fdcdef635d0fe0e45-300-dp-5.png" alt="300-dp-5.png">,<img src="https://pic.leetcode-cn.com/67bb112cf4c6108ed6b336cc5c7c063a36f9f27170bd858c72d16a6fe3716d26-300-dp-6.png" alt="300-dp-6.png">,<img src="https://pic.leetcode-cn.com/992f2753a13549df41b51c392f8ab1af2f5f64353459029a3ae064ad6cc733c8-300-dp-7.png" alt="300-dp-7.png">,<img src="https://pic.leetcode-cn.com/d34f761b4641d156e2a5e4e336d6a67c0e957a596f7c6c4b92cefc157a16ccd9-300-dp-8.png" alt="300-dp-8.png">,<img src="https://pic.leetcode-cn.com/d87192e0d6e30eaaa1372b2be989d776f6a22a0929755d8af1c5ab2a10e9c532-300-dp-9.png" alt="300-dp-9.png"></p> <p><strong>参考代码 1</strong>：</p> <p>Python 代码：</p> <div class="language-Python [] extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>

    <span class="token comment"># 将 dp 数组定义为：以 nums[i] 结尾的最长上升子序列的长度</span>
    <span class="token comment"># 那么题目要求的，就是这个 dp 数组中的最大者</span>
    <span class="token comment"># 以数组  [10, 9, 2, 5, 3, 7, 101, 18] 为例</span>
    <span class="token comment"># dp 的值： 1  1  1  2  2  3  4    4</span>

    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token comment"># 特判</span>
        <span class="token keyword">if</span> size <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> size
        
        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> size
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token comment"># + 1 的位置不要加错了</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment"># 最后要全部一看遍，取最大值</span>
        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>
</code></pre></div><p>Python 代码：</p> <div class="language-Java [] extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">Arrays</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>

    <span class="token comment">//【关键】将 dp 数组定义为：以 nums[i] 结尾的最长上升子序列的长度</span>
    <span class="token comment">// 那么题目要求的，就是这个 dp 数组中的最大者</span>
    <span class="token comment">// 以数组  [10, 9, 2, 5, 3, 7, 101, 18] 为例：</span>
    <span class="token comment">// dp 的值： 1  1  1  2  2  3  4    4</span>
    <span class="token comment">// 注意实现细节。</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 状态的定义是：以 i 结尾的最长上升子序列的长度</span>
        <span class="token comment">// 状态转移方程：之前比最后那个数字小的最长上升子序列的长度 + 1</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果只有 1 个元素，那么这个元素自己就构成了最长上升子序列，所以设置为 1 是合理的</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 从第 2 个元素开始，逐个写出 dp 数组的元素的值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> curVal <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 找出比当前元素小的哪些元素的最小值</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>curVal <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 最后要全部走一遍，看最大值</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">Solution</span> solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> lengthOfLIS <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lengthOfLIS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>复杂度分析：</strong></p> <ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，因为有两个 <code>for</code> 循环，每个 <code>for</code> 循环的时间复杂度都是线性的。</li> <li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，要开和数组等长的状态数组，最后要拉通看一遍状态数组的最大值，因此空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li></ul> <p>这道题还有一个时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的解法，把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span> 其中一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 降到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\log N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>，就是如下的“贪心算法 + 二分查找”。</p> <h3 id="方法二：贪心算法-二分查找"><a href="#方法二：贪心算法-二分查找" aria-hidden="true" class="header-anchor">#</a> 方法二：贪心算法 + 二分查找</h3> <p>首先我们介绍算法的基本思想。</p> <h4 id="算法的基本思想："><a href="#算法的基本思想：" aria-hidden="true" class="header-anchor">#</a> 算法的基本思想：</h4> <blockquote><p><strong>如果前面的数越小，后面接上一个随机数，就会有更大的可能性构成一个更长的“上升子序列”。</strong></p></blockquote> <p>这个思想并不难理解，我们举例说明：如果前面的数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>，后面接上一个随机数，能够构成长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 的“上升子序列”的可能性，就远远大于前面的数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>，后面接上一个随机数，能够构成长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 的“上升子序列”的可能性。</p> <p>基于这个思想，我们先通过示例介绍算法的流程，然后再做总结，最后把其中关键的地方向大家指出。我在示例的数组后面加上了 <code>4</code>、<code>8</code>、<code>6</code>、<code>12</code>。</p> <p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p> <p><img src="https://pic.leetcode-cn.com/ecfe05bf65309a085484489b9dbf0d354ebd04254aa192ae08712dfe02dc2a0c-300-greed-binary-search-1.png" alt="300-greed-binary-search-1.png">,<img src="https://pic.leetcode-cn.com/f30cf9c7fee1577ea3cdab964198aabfd64e566801e7a2f671be1209fdbe93b7-300-greed-binary-search-2.png" alt="300-greed-binary-search-2.png">,<img src="https://pic.leetcode-cn.com/2ad160a3cb5cb5a9e6f305e7e4f373a4bcf9694364502ae18cfa42616fbc50f8-300-greed-binary-search-3.png" alt="300-greed-binary-search-3.png">,<img src="https://pic.leetcode-cn.com/462331c85f2cff24d7843e4d2d20b6cf053ec5a66090c300d6725bce35adffa0-300-greed-binary-search-4.png" alt="300-greed-binary-search-4.png">,<img src="https://pic.leetcode-cn.com/65eeee3079908c510ab18a58fc79a759bc990fc5f475ce11a4bd5703718fa297-300-greed-binary-search-5.png" alt="300-greed-binary-search-5.png">,<img src="https://pic.leetcode-cn.com/542301ec25d4b7c6ff5bfe2247b0c93ef0c8de2d6dcdd8d31de1fd76ca023dc6-300-greed-binary-search-6.png" alt="300-greed-binary-search-6.png">,<img src="https://pic.leetcode-cn.com/d25ebf30e65f08539631b99877fe3e680dc610174e480d3138316bd4b0fd4bb0-300-greed-binary-search-7.png" alt="300-greed-binary-search-7.png">,<img src="https://pic.leetcode-cn.com/d879eee3c8d23d24100c78191a11b2400de1c947fbaad664326d03a031406a3a-300-greed-binary-search-8.png" alt="300-greed-binary-search-8.png">,<img src="https://pic.leetcode-cn.com/7008940585efaf7e11f2b50539f654d38083eda3f4be4af9545f82499520117a-300-greed-binary-search-9.png" alt="300-greed-binary-search-9.png">,<img src="https://pic.leetcode-cn.com/fa286e2662037237697ee1487b66ebdd60cc4d43dea6c629736e5804d0c47502-300-greed-binary-search-10.png" alt="300-greed-binary-search-10.png">,<img src="https://pic.leetcode-cn.com/4ea79c933335d3589ea30d0069bc5f0d6370a4e1ccf7340ce36150707ed38d57-300-greed-binary-search-11.png" alt="300-greed-binary-search-11.png">,<img src="https://pic.leetcode-cn.com/1482b6fd5b6616b13dc2c2d7c58d20e0aedef555102e8d7201e66e6b080185ca-300-greed-binary-search-12.png" alt="300-greed-binary-search-12.png">,<img src="https://pic.leetcode-cn.com/66ed49450c9973febfa84fed76229bdc236a480f6554741519f9f22cec033539-300-greed-binary-search-13.png" alt="300-greed-binary-search-13.png">,<img src="https://pic.leetcode-cn.com/df18b7a8889e28ec2c0a11a89385f0814d034bb0d3caf95d242e41683a5f382c-300-greed-binary-search-14.png" alt="300-greed-binary-search-14.png">,<img src="https://pic.leetcode-cn.com/09cc26acbdc0fe62ec9a79d95d0bb878c0abd8b2af61f7330098ac1b7ddf8e42-300-greed-binary-search-15.png" alt="300-greed-binary-search-15.png">,<img src="https://pic.leetcode-cn.com/5affa5e17cdbb96e7bdd4659cb8553d64727ee895383629c4d927dd80fc6fefa-300-greed-binary-search-16.png" alt="300-greed-binary-search-16.png">,<img src="https://pic.leetcode-cn.com/1805c1d89a77358fbaba1419d86c7c489afd857c6afd817d657c0bd1e200aa86-300-greed-binary-search-17.png" alt="300-greed-binary-search-17.png">,<img src="https://pic.leetcode-cn.com/20b8de5654fff413a00c1d7bd3204a4930731d0b342dbc2ba4cfa41c89f6a6a3-300-greed-binary-search-18.png" alt="300-greed-binary-search-18.png">,<img src="https://pic.leetcode-cn.com/677a66d92579ced1b67c114c90f1dafb499bd2dd198b93acc440d18e32ede7f1-300-greed-binary-search-19.png" alt="300-greed-binary-search-19.png">,<img src="https://pic.leetcode-cn.com/39eb82360d5ad5314e1f649a267c821cca8a5b7f1a705d9985596bb423a2487e-300-greed-binary-search-20.png" alt="300-greed-binary-search-20.png">,<img src="https://pic.leetcode-cn.com/fb069e6f4e36257acf00dbce1bc832002ce68289016b57aa0b2ac0b1f0150a77-300-greed-binary-search-21.png" alt="300-greed-binary-search-21.png"></p> <h4 id="算法的执行流程："><a href="#算法的执行流程：" aria-hidden="true" class="header-anchor">#</a> 算法的执行流程：</h4> <p>1、设置一个有序数组 <code>tail</code>，初始时为空；</p> <blockquote><p>数组命名为 <code>tail</code> 即 PPT 中各个行表示的数组（是一个“上升子序列”）的结尾，注意：<strong>有序数组 <code>tail</code> 虽然有“上升”的性质，但它不是每时每刻都表示问题中的“最长上升子序列”（下文还会强调）</strong>，不能命名为 <code>LIS</code>，有序数组 <code>tail</code> 是用于求解 <code>LIS</code> 问题的辅助数组。</p></blockquote> <p>2、在遍历数组 <code>nums</code> 的过程中，每来一个新数 <code>num</code>，如果这个数<strong>严格</strong>大于有序数组 <code>tail</code> 的最后一个元素，就把 <code>num</code> 放在有序数组 <code>tail</code> 的后面，否则进入第 3 点；</p> <blockquote><p>注意：这里的大于是“严格”大于，不包括等于的情况。</p></blockquote> <p>3、在有序数组 <code>tail</code> 中查找第 1 个等于大于 <code>num</code> 的那个数，试图让它变小；</p> <ul><li>如果有序数组 <code>tail</code> 中存在等于 <code>num</code> 的元素，什么都不做，因为以 <code>num</code> 结尾的最短的“上升子序列”已经存在；</li> <li>如果有序数组 <code>tail</code> 中存在大于 <code>num</code> 的元素，找到第 1 个，让它变小，这样我们就找到了一个“结尾更小”的“相同长度”的上升子序列。</li></ul> <p>这一步可以使用“二分查找法”。</p> <p>4、遍历新的数 <code>num</code> ，先尝试上述第 2 点，第 2 点行不通则执行第 3 点，直到遍历完整个数组 <code>nums</code>，最终<strong>有序数组 <code>tail</code> 的长度，就是所求的“最长上升子序列”的长度</strong>。</p> <h4 id="算法的关键之处："><a href="#算法的关键之处：" aria-hidden="true" class="header-anchor">#</a> 算法的关键之处：</h4> <p>以上算法能够奏效的关键是：</p> <blockquote><p>最开始提到的“基本思想”，可以认为是一种“贪心选择”的思想：<strong>只要让前面的数尽量小，在算法的执行过程中，第 2 点被执行的机会就越多</strong>。</p></blockquote> <p>下面从算法运行的角度看一个具体的例子，此时我们使用的辅助数组是一维的，以便于您理解算法的基本思想和执行流程。</p> <p>以下 2 点注意事项，请读者结合示例认真体会。</p> <h4 id="注意事项："><a href="#注意事项：" aria-hidden="true" class="header-anchor">#</a> 注意事项：</h4> <blockquote><p>1、<strong>虽然有序数组 <code>tail</code> 是升序数组，但是这个数组并不是每时每刻都表示题目要求的那个“最长上升子序列”</strong>，这一点你可以在我上面的例子中找到例证；</p></blockquote> <p>有序数组 <code>tail</code> 可以这样理解：</p> <blockquote><p><code>tail[i]</code> 表示长度为 <code>i + 1</code> （因为 <code>i</code> 表示索引，<code>i + 1</code> 表示长度）的所有“上升子序列”里<strong>结尾最小的元素</strong>。</p></blockquote> <p>因此， 有序数组 <code>tail</code> 的长度就是题目所求的“最长上升子序列”的长度。</p> <blockquote><p>2、“贪心选择性质”保证了算法流程的第 2 点有更多机会被执行。</p></blockquote> <p>下面看一个具体的例子，理解算法是如何借助一个一维数组完成“最长上升子序列”的长度的求解过程。</p> <p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p> <p><img src="https://pic.leetcode-cn.com/1b689575e70cf2e3277db2a52c915ceb8b2c5a5dd63f17e1e41bab1a63a08834-300-greed-binary-search-1.png" alt="300-greed-binary-search-1.png">,<img src="https://pic.leetcode-cn.com/d7caa3f868103141e166a95fdbfe2f5c9954df15f4d4f35d39f6a85c47ee2c1a-300-greed-binary-search-2.png" alt="300-greed-binary-search-2.png">,<img src="https://pic.leetcode-cn.com/3a1ebf006e4a14f3a434b3ba06992d33ad6cdc1a87c82c2bf7379606af7e35a3-300-greed-binary-search-3.png" alt="300-greed-binary-search-3.png">,<img src="https://pic.leetcode-cn.com/2046268817168f15030996246d05ef515137193986ee403e70dfa72d90108937-300-greed-binary-search-4.png" alt="300-greed-binary-search-4.png">,<img src="https://pic.leetcode-cn.com/fc5ae517f330562c76ed571f775d4cbae6d3b17fb47f2d51a75b5190f5aac831-300-greed-binary-search-5.png" alt="300-greed-binary-search-5.png">,<img src="https://pic.leetcode-cn.com/70df664d516bfcdcc40c8996fbae00f8ede268b1e51f735b6259df429d8fe5e0-300-greed-binary-search-6.png" alt="300-greed-binary-search-6.png">,<img src="https://pic.leetcode-cn.com/032aeb1edf40f192cc94748db3a6ec550a63b77b9c01b5041eac490e14dbdd9f-300-greed-binary-search-7.png" alt="300-greed-binary-search-7.png">,<img src="https://pic.leetcode-cn.com/382f41b81c386854640e89846e25fb832ac387ca8fa4b55c01d8727f13de8cad-300-greed-binary-search-8.png" alt="300-greed-binary-search-8.png">,<img src="https://pic.leetcode-cn.com/1f04b581689ec3d767ca2e47bd9ec5ff5be8e42c209ba083f5c561e56777a846-300-greed-binary-search-9.png" alt="300-greed-binary-search-9.png">,<img src="https://pic.leetcode-cn.com/e5c43b8d010c2195995671ed1d77f62dd8532ac58bc4e505d6c08e88e31fd67c-300-greed-binary-search-10.png" alt="300-greed-binary-search-10.png">,<img src="https://pic.leetcode-cn.com/51b414c660e660aeef405c985dc893a51f248c50f74deaf9b0db9f579cfbf316-300-greed-binary-search-11.png" alt="300-greed-binary-search-11.png">,<img src="https://pic.leetcode-cn.com/142c43d4b5f73321a15dd1cee1e76fc1b3b8b15f88ee56932c20d7668ad23f99-300-greed-binary-search-12.png" alt="300-greed-binary-search-12.png">,<img src="https://pic.leetcode-cn.com/4ef6f4533d362c1dd71cd9d9164b6770aefea79382adb4fdacb3fed4bebbfd4c-300-greed-binary-search-13.png" alt="300-greed-binary-search-13.png">,<img src="https://pic.leetcode-cn.com/b28c5f7b20a26fb737df8f4852ae4dc0ef86358074f91b0c197c3312ac10f857-300-greed-binary-search-14.png" alt="300-greed-binary-search-14.png">,<img src="https://pic.leetcode-cn.com/0c6ceb7589a5e50b5841d7b0151a6e781883e0ec1329d5d55faa8423fd2673d6-300-greed-binary-search-15.png" alt="300-greed-binary-search-15.png">,<img src="https://pic.leetcode-cn.com/1d7d74c19ddca68d72da6d6b2e052808fd39338e17604cb32f5bc85097bb19c1-300-greed-binary-search-16.png" alt="300-greed-binary-search-16.png">,<img src="https://pic.leetcode-cn.com/ab176390bd7456686b284a7dbabb6d3344a7c80e3c76488edd608ce7e4c1a7ac-300-greed-binary-search-17.png" alt="300-greed-binary-search-17.png">,<img src="https://pic.leetcode-cn.com/3edc70da31868787389a1e7f21f99b18bbcc46b3d0ea0b91e669d7d8e4fe8add-300-greed-binary-search-18.png" alt="300-greed-binary-search-18.png">,<img src="https://pic.leetcode-cn.com/0509d9bd8cf3ba16f214ba167c788de8de844973b19babe6d340aaf1d2403469-300-greed-binary-search-19.png" alt="300-greed-binary-search-19.png">,<img src="https://pic.leetcode-cn.com/90445c749b6ac0aea818f1b319e5cf915d6d6034ed369cc3d830015af122f36b-300-greed-binary-search-20.png" alt="300-greed-binary-search-20.png">,<img src="https://pic.leetcode-cn.com/d041c8c765c1d8faa104fb72030e9c60c3b2bbc2590290004b4ec69c23d63926-300-greed-binary-search-21.png" alt="300-greed-binary-search-21.png">,<img src="https://pic.leetcode-cn.com/449ee08b72c8dc11ab69a85ee7b4bae2f58138cf1a0735e700e8004f98c8bf4a-300-greed-binary-search-22.png" alt="300-greed-binary-search-22.png">,<img src="https://pic.leetcode-cn.com/bb06b80e3a74944abaeae39f21cb4e23352d991cf03564dd4316eb353a7af27d-300-greed-binary-search-23.png" alt="300-greed-binary-search-23.png"></p> <p>下面是本解法的参考代码，在这个参考代码中，我使用了一个二分查找法的模板，我把使用这个二分查找法模板的优点、注意事项和调试方法都写在了「力扣 第 35 题：“搜索插入位置”的题解： <a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener noreferrer">《特别好用的二分查找法模板（Python 代码、Java 代码）》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，如果你能够分析出我给出的两个 Python 版本代码和两个 Java 版本代码关于二分查找的不同之处，那就说明你已经掌握了这个模板，相信会对您今后准确使用二分查找法有一定帮助。</p> <p>理解了这个方法以后，朋友们不妨尝试挑战一下<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener noreferrer">「力扣」第 354 题：“俄罗斯套娃信封问题”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h4 id="参考代码："><a href="#参考代码：" aria-hidden="true" class="header-anchor">#</a> 参考代码：</h4> <p><strong>参考代码 2</strong>：严格按照以上算法执行流程写出来的代码。</p> <p>Python 代码：</p> <div class="language-Python [] extra-class"><pre class="language-python"><code><span class="token keyword">from</span> typing <span class="token keyword">import</span> List


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token comment"># 特判</span>
        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> size

        <span class="token comment"># 为了防止后序逻辑发生数组索引越界，先把第 1 个数放进去</span>
        tail <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大</span>
            <span class="token comment"># 先尝试是否可以接在末尾</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tail<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                tail<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span>

            <span class="token comment"># 使用二分查找法，在有序数组 tail 中</span>
            <span class="token comment"># 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小</span>
            left <span class="token operator">=</span> <span class="token number">0</span>
            right <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>
                <span class="token comment"># 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解</span>
                <span class="token comment"># mid = left + (right - left) // 2</span>
                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>
                <span class="token keyword">if</span> tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token comment"># 中位数肯定不是要找的数，把它写在分支的前面</span>
                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    right <span class="token operator">=</span> mid
            <span class="token comment"># 走到这里是因为【逻辑 1】的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素，因此无需再单独判断</span>
            tail<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span>
</code></pre></div><p>Python 代码：</p> <div class="language-Java [] extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 特判</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> len<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 遍历第 1 个数，直接放在有序数组 tail 的开头</span>
        tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// end 表示有序数组 tail 的最后一个已经赋值元素的索引</span>

        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 直接添加在那个元素的后面，所以 end 先加 1</span>
                end<span class="token operator">++</span><span class="token punctuation">;</span>
                tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 使用二分查找法，在有序数组 tail 中</span>
                <span class="token comment">// 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小</span>
                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解</span>
                    <span class="token comment">// int mid = left + (right - left) / 2;</span>
                    <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 中位数肯定不是要找的数，把它写在分支的前面</span>
                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 走到这里是因为 【逻辑 1】 的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素</span>
                <span class="token comment">// 因此，无需再单独判断</span>
                tail<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 调试方法</span>
            <span class="token comment">// printArray(nums[i], tail);</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 此时 end 是有序数组 tail 最后一个元素的索引</span>
        <span class="token comment">// 题目要求返回的是长度，因此 +1 后返回</span>
        end<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 调试方法，以观察是否运行正确</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;当前数字：&quot;</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;\t当前 tail 数组：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> tail<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tail<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">Solution8</span> solution8 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> lengthOfLIS <span class="token operator">=</span> solution8<span class="token punctuation">.</span><span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;最长上升子序列的长度：&quot;</span> <span class="token operator">+</span> lengthOfLIS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>参考代码 3</strong>：与“参考代码 1 ”等价的代码，区别仅在于“二分查找法”候选区间的选择。</p> <p>Python 代码：</p> <div class="language-Python [] extra-class"><pre class="language-python"><code><span class="token keyword">from</span> typing <span class="token keyword">import</span> List


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token comment"># 特判</span>
        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> size
        <span class="token comment"># tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几</span>
        <span class="token comment"># 遍历第 1 个数，直接放在有序数组 tail 的开头</span>
        tail <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 找到大于等于 num 的第 1 个数，试图让它变小</span>
            left <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token comment"># 因为有可能 num 比 tail 数组中的最后一个元素还要大，</span>
            <span class="token comment"># 【逻辑 1】所以右边界应该设置为 tail 数组的长度</span>
            right <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span>
            <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>
                <span class="token comment"># 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解</span>
                <span class="token comment"># mid = left + (right - left) // 2</span>
                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>

                <span class="token keyword">if</span> tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token comment"># 中位数肯定不是要找的数，把它写在分支的前面</span>
                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    right <span class="token operator">=</span> mid
            <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">:</span>
                tail<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 因为【逻辑 1】，因此一定能找到第 1 个大于等于 nums[i] 的元素，因此无需再单独判断，直接更新即可</span>
                tail<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span>
</code></pre></div><p>Python 代码：</p> <div class="language-Java [] extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 特判</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> len<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 遍历第 1 个数，直接放在有序数组 tail 的开头</span>
        tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// end 表示有序数组 tail 的最后一个已经赋值元素的索引</span>

        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里，因为当前遍历的数，有可能比有序数组 tail 数组实际有效的末尾的那个元素还大</span>
            <span class="token comment">// 【逻辑 1】因此 end + 1 应该落在候选区间里</span>
            <span class="token keyword">int</span> right <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解</span>
                <span class="token comment">// int mid = left + (right - left) / 2;</span>
                <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 中位数肯定不是要找的数，把它写在分支的前面</span>
                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    right <span class="token operator">=</span> mid<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 因为 【逻辑 1】，因此一定能找到第 1 个大于等于 nums[i] 的元素</span>
            <span class="token comment">// 因此，无需再单独判断，直接更新即可</span>
            tail<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token comment">// 但是 end 的值，需要更新，当前仅当更新位置在当前 end 的下一位</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                end<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
        <span class="token comment">// 调试方法</span>
        <span class="token comment">// printArray(nums[i], tail);</span>
        <span class="token comment">// 此时 end 是有序数组 tail 最后一个元素的索引</span>
        <span class="token comment">// 题目要求返回的是长度，因此 +1 后返回</span>
        end<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 调试方法，以观察是否运行正确</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;当前数字：&quot;</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;\t当前 tail 数组：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> tail<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tail<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">Solution9</span> solution9 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution9</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> lengthOfLIS <span class="token operator">=</span> solution9<span class="token punctuation">.</span><span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;最长上升子序列的长度：&quot;</span> <span class="token operator">+</span> lengthOfLIS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>复杂度分析</strong>：</p> <ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，遍历数组使用了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，二分查找法使用了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li> <li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，开辟有序数组 <code>tail</code> 的空间至多和原始数组一样。</li></ul> <!----></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0139-word-break.html" class="prev">
          LeetCode 第 139 题：“单词拆分”题解
        </a></span> <span class="next"><a href="/leetcode-solution-blog/leetcode-problemset/dynamic-programming/0377-combination-sum-iv.html">
          LeetCode 第 377 题：“组合总和 Ⅳ”题解
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/leetcode-solution-blog/assets/js/app.465160d1.js" defer></script><script src="/leetcode-solution-blog/assets/js/2.3821944f.js" defer></script><script src="/leetcode-solution-blog/assets/js/61.8982a5c8.js" defer></script>
  </body>
</html>
